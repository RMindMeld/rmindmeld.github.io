{
  "hash": "578c8ac776d2b4a55aee28a740af44c6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Programming in Stata with AI: An Experiment of Success\"\ndate: \"2024-11-26\"\ncategories: \n  - Programming\n  - AI Experiments\n  - Stata\nimage: \"../../assets/blog/ai-prog-stata.jpg\"\nexecute: \n  freeze: auto\n---\n\n\n\n## The Story Behind This Experiment\n\nAs many other economists, I some time spend quite a lot of time working with my Stata code and programs, debugging, trying, testing, to make sure everything is working as it should. Usually that is not much of a problem with programs for isolated projects. But, trying to do that with ado's that are ment to be used by others, it can be quite a challenge.\n\nThat is not unexpected. Working with specific tasks usually requires lots of data cleaning, data wrangling, labeling, and so on. It is an easy task, but its time consuming and tedious. But we all have done it. \n\nThe task that can take even more time consuming and daunting is when you are working with a highly complex analysis, or even more, when you are developing a new program that will be used by others.\nPerhaps one of those programs that was the stone in my shoe was the estimation of unconditional quantile regression models using RIF regressions. It took quite some time for me to get it right, and expand it to a sufficiently general program that could be used by others: `rifhdreg`\n\nWhen I heard about Stata, one of the first questions I asked was for it to give me code to estimate unconditional quantile regression models. and guess what...it did!...hallucinate!. Asking about implementing the program from scratch was out of the question. This is not too surprising. We know that Stata is a somewhat niche programming Language, and being proprietary, it is not as popular as Python or R. So the \"training\" of AI is very limited.\n\n## How Proficient is AI in Stata?\n\nFrom all competing AI models, the one I have been using for programming is Claude.ai. It is suppoused to excell in programming. However, if you ask it about its proficiency using the following prompt: \n\n> Scale 0-100 , provide your own assessment on profficiency on Stata R Python Julia SQL Basic C++ Rubi, Scratch, Pascal, and any other programs you have heard off\n\nYou get:\n\n| Language | Proficiency |\n|----------|-------------|\n| Python   | 95/100      |\n| R        | 90/100      |\n| SQL      | 90/100      |\n| Julia    | 85/100      |\n| Stata    | 80/100      |\n| C++      | 75/100      |\n| Ruby     | 70/100      |\n| Pascal   | 65/100      |\n| Scratch  | 60/100      |\n| MATLAB   | 75/100      |\n| SAS      | 70/100      |\n| Fortran  | 65/100      |\n| Perl     | 60/100      |\n| SPSS     | 60/100      |\nLanguage Proficiency  \n\nKeep in mind that the first time I asked this, it gave itself a 60/100 on Stata. It has now increased to 80/100. It is still below R or Python, but it is quite good. So with the newest models, I thought...perhaps it can also help with Stata programming.\n\n## The Experiment: Zero-prompt Stata Programming\n\nI decided to give it a try. I would use Claude.ai and give it a zero-prompt, and see if it could help me with Stata programming. The prompt was direct:\n\n> Write a Stata program that implements the estimation of unconditional quantile regression models using RIF regressions from scratch.\n\nThe result was quite surprising. It game me a full program, including an example of how to use it! It also cited Firpo, Fortin, and Lemieux (2009) as the reference for the method. \n\nLooking at the code, it was quite good. It had all the necessary components, including the kernel density estimation for the RIF, the computation of the sample quantile, and the estimation of the RIF regression. It even had an option for bootstrapped standard errors, and with good documentation.\n\n::: {#6c8e69e9 .cell execute='false' execution_count=1}\n``` {.stata .cell-code code-fold=\"true\"}\ncapture program drop rifqreg\nprogram define rifqreg, eclass\n    version 14.0\n    \n    syntax varlist(min=2) [if] [in] [aweight fweight pweight], ///\n        Quantile(real) ///\n        [vce(string) Robust CLuster(varname) reps(integer 50)]\n    \n    marksample touse\n    gettoken depvar indepvars : varlist\n    \n    // Check quantile is between 0 and 1\n    if `quantile' <= 0 | `quantile' >= 1 {\n        di as error \"quantile() must be between 0 and 1\"\n        exit 198\n    }\n    \n    // Handle weights\n    local weight \"\"\n    if \"`weight'\" != \"\" {\n        local weight \"[`weight'`exp']\"\n    }\n    \n    // Get sample size\n    qui count if `touse'\n    local N = r(N)\n    \n    // Compute the sample quantile\n    tempvar y_sorted\n    qui sort `depvar'\n    qui gen `y_sorted' = `depvar' if `touse'\n    _pctile `y_sorted' `weight' if `touse', p(`=`quantile'*100')\n    local q_tau = r(r1)\n    \n    // Compute the density at the quantile using kernel density estimation\n    tempvar kde_est\n    qui kdensity `depvar' if `touse', nograph generate(`kde_est') at(`q_tau')\n    local f_tau = `r(density)'\n    \n    // Generate RIF\n    tempvar rif\n    qui gen `rif' = `q_tau' + ///\n        (`depvar' <= `q_tau' - `quantile')/`f_tau' if `touse'\n    \n    // Estimate RIF regression\n    if \"`vce'\" == \"bootstrap\" {\n        qui bootstrap _b, reps(`reps'): regress `rif' `indepvars' if `touse' `weight'\n    }\n    else {\n        local vcetype \"\"\n        if \"`robust'\" != \"\" | \"`cluster'\" != \"\" {\n            local vcetype \"robust\"\n            if \"`cluster'\" != \"\" {\n                local vcetype \"`vcetype' cluster(`cluster')\"\n            }\n        }\n        qui regress `rif' `indepvars' if `touse' `weight', `vcetype'\n    }\n    \n    // Store results\n    ereturn local cmd \"rifqreg\"\n    ereturn local title \"RIF-based Unconditional Quantile Regression\"\n    ereturn scalar q_tau = `q_tau'\n    ereturn scalar f_tau = `f_tau'\n    ereturn scalar tau = `quantile'\n    \n    // Display results\n    di _n as txt \"RIF-based Unconditional Quantile Regression\"\n    di as txt \"Quantile: \" as res `quantile'\n    di as txt \"Sample quantile value: \" as res `q_tau'\n    di as txt \"Density estimate at quantile: \" as res `f_tau'\n    di _n\n    ereturn display\nend\n\n// Helper program for generating RIF values\ncapture program drop gen_rif\nprogram define gen_rif\n    syntax varname, Quantile(real) GENerate(name)\n    \n    tempvar y_sorted kde_est\n    qui sort `varlist'\n    qui gen `y_sorted' = `varlist'\n    \n    _pctile `y_sorted', p(`=`quantile'*100')\n    local q_tau = r(r1)\n    \n    qui kdensity `varlist', nograph generate(`kde_est') at(`q_tau')\n    local f_tau = `r(density)'\n    \n    qui gen `generate' = `q_tau' + ///\n        (`varlist' <= `q_tau' - `quantile')/`f_tau'\nend\n\n// Example usage:\n/*\n* Load data\nsysuse auto, clear\n\n* Run unconditional quantile regression at median\nrifqreg price weight length foreign, q(0.5) robust\n\n* Run unconditional quantile regression at 75th percentile with bootstrapped SE\nrifqreg price weight length foreign, q(0.75) vce(bootstrap) reps(100)\n\n* Generate RIF values for manual analysis\ngen_rif price, q(0.5) gen(rif_price50)\n*/\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<style>div.jp-Notebook .datagrid-container {min-height: 448px; }</style>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n```\n:::\n:::\n\n\nBut does it work?? \n\nNope...\n\nThere are few errors in the program that can be easily to fix. Nevertheless, the results were impresive. And while I could (and have) implemented this from scratch. If I were to program this today, this could have certainly saved me a lot of time. But...there is still a long way to go. As I mentioned, there were few errors that need fixing, in addition to some programming choices that are definately not something I would have done. \n\n1. I would produce UQR using the median as default. The current program asks you to provide a value for quantiles.\n2. I like to use a range 0-100 for quantiles instead of 0-1.\n\nAnd what needs fixing?\n\n1. The way the density is computed is not correct. Calls on `kdensity` using `at()` option, but using a value rather than a variable. (easy fix)\n2. The RIF function is slighly off as well\n\nthe program uses:\n\n```stata\ngen `rif' = `q_tau' + (`depvar' <= `q_tau' - `quantile')/`f_tau' if `touse'\n```\n\nBut it should be:\n\n```stata\ngen `rif' = `q_tau' + ((`depvar' >= `q_tau')- `quantile')/`f_tau' if `touse'\n```                  \n\nHere is the program with the changes:\n\n::: {#abc5e8bb .cell execute='false' execution_count=2}\n``` {.stata .cell-code code-fold=\"true\"}\ncapture program drop rifqreg\nprogram define rifqreg, eclass\n    version 14.0\n    \n    syntax varlist(min=2) [if] [in] [aweight fweight pweight], ///\n        Quantile(real) ///\n        [vce(string) Robust CLuster(varname) reps(integer 50)]\n    \n    marksample touse\n    gettoken depvar indepvars : varlist\n    \n    // Check quantile is between 0 and 1\n    if `quantile' <= 0 | `quantile' >= 1 {\n        di as error \"quantile() must be between 0 and 1\"\n        exit 198\n    }\n    \n    // Handle weights\n    local weight \"\"\n    if \"`weight'\" != \"\" {\n        local weight \"[`weight'`exp']\"\n    }\n    \n    // Get sample size\n    qui count if `touse'\n    local N = r(N)\n    \n    // Compute the sample quantile\n    tempvar y_sorted\n    qui sort `depvar'\n    qui gen `y_sorted' = `depvar' if `touse'\n    _pctile `y_sorted' `weight' if `touse', p(`=`quantile'*100')\n    local q_tau = r(r1)\n    \n    // Compute the density at the quantile using kernel density estimation\n    tempvar kde_est\n\ttempvar q_tau_v\n\tqui: gen double `q_tau_v' = `q_tau' in 1\n    qui kdensity `depvar' if `touse', nograph generate(`kde_est') at(`q_tau_v')\n    local f_tau = `kde_est'[1]\n    \n    // Generate RIF\n    tempvar rif\n    qui gen `rif' = `q_tau' + ///\n        ((`depvar' >= `q_tau' )- `quantile')/`f_tau' if `touse'\n    \n    // Estimate RIF regression\n    if \"`vce'\" == \"bootstrap\" {\n        qui bootstrap _b, reps(`reps'): regress `rif' `indepvars' if `touse' `weight'\n    }\n    else {\n        local vcetype \"\"\n        if \"`robust'\" != \"\" | \"`cluster'\" != \"\" {\n            local vcetype \"robust\"\n            if \"`cluster'\" != \"\" {\n                local vcetype \"`vcetype' cluster(`cluster')\"\n            }\n        }\n        qui regress `rif' `indepvars' if `touse' `weight', `vcetype'\n    }\n    \n    // Store results\n    ereturn local cmd \"rifqreg\"\n    ereturn local title \"RIF-based Unconditional Quantile Regression\"\n    ereturn scalar q_tau = `q_tau'\n    ereturn scalar f_tau = `f_tau'\n    ereturn scalar tau = `quantile'\n    \n    // Display results\n    di _n as txt \"RIF-based Unconditional Quantile Regression\"\n    di as txt \"Quantile: \" as res `quantile'\n    di as txt \"Sample quantile value: \" as res `q_tau'\n    di as txt \"Density estimate at quantile: \" as res `f_tau'\n    di _n\n    ereturn display\nend\n\n// Helper program for generating RIF values\ncapture program drop gen_rif\nprogram define gen_rif\n    syntax varname, Quantile(real) GENerate(name)\n    \n    tempvar y_sorted kde_est\n    qui sort `varlist'\n    qui gen `y_sorted' = `varlist'\n    \n    _pctile `y_sorted', p(`=`quantile'*100')\n    local q_tau = r(r1)\n    \n    qui kdensity `varlist', nograph generate(`kde_est') at(`q_tau')\n    local f_tau = `r(density)'\n    \n    qui gen `generate' = `q_tau' + ///\n        (`varlist' <= `q_tau' - `quantile')/`f_tau'\nend\n\n// Example usage:\n/*\n* Load data\nsysuse auto, clear\n\n* Run unconditional quantile regression at median\nrifqreg price weight length foreign, q(0.5) robust\n\n* Run unconditional quantile regression at 75th percentile with bootstrapped SE\nrifqreg price weight length foreign, q(0.75) vce(bootstrap) reps(100)\n\n* Generate RIF values for manual analysis\ngen_rif price, q(0.5) gen(rif_price50)\n*/\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n```\n:::\n:::\n\n\nAnd now produces results comparable to my own `rifhdreg` program. I have not tested its other features.\n\n## What else?\n\nSomething else I some times \"dread\" to do is documentation. One thing is to write how my code works for me, and another is to write a helpfile for others. And to be honest, SMCL (Stata Markup language) is not very intuitive. But no problem!. With the program above, and sketch of a helpfile, Claude.ai could write it as well.\n\nUnfortunately, I cannot use `sonnet` right now, so what you see below is based on `haiku` model.\n\nHere the prompt:\n\n> using the attached program, write a helpfile following standard syntax for Stata \n\nAnd again, the result was impresive. It produced a helpfile that was quite good. It had all the necessary components, including the syntax, the description, the options, the examples, and the references. All using SMCL.\n\nIt even had place holders for my own information. (Author? I wonder if it should be Claude!)\n\nHere it is. If you want to see the result, you can copy/paste into a new file and save it as `rifqreg.sthlp`. Then click on \"show file in viewer\" to see the result.\n\n::: {#c97339b5 .cell execute='false' execution_count=3}\n``` {.stata .cell-code code-fold=\"true\"}\n/*\n{smcl}\n{* *! version 1.0.0  26Nov2024}\n{title:Title}\n\n{phang}\n{cmd:rifqreg} {hline 2} RIF-based Unconditional Quantile Regression\n\n{title:Syntax}\n\n{p 8 17 2}\n{cmd:rifqreg} {depvar} {indepvars} {ifin} \n{cmd:,} {opt q:uantile(#)} \n[{opt vce(vcetype)} {opt rob:ust} {opt clus:ter(varname)} {opt reps(#)}]\n\n{p 8 17 2}\n{cmd:gen_rif} {varname} {cmd:,} {opt q:uantile(#)} {opt gen:erate(newvar)}\n\n{title:Description}\n\n{pstd}\n{cmd:rifqreg} performs RIF-based (Recentered Influence Function) unconditional quantile regression. \nThis method allows estimation of the impact of covariates on a specific quantile of the outcome distribution.\n\n{pstd}\n{cmd:gen_rif} is a helper command that generates Recentered Influence Function values for a specified quantile.\n\n{title:Options}\n\n{dlgtab:Main}\n\n{phang}\n{opt q:uantile(#)} Specifies the quantile to estimate. Must be a value between 0 and 1.\n\n{dlgtab:Variance Estimation}\n\n{phang}\n{opt vce(vcetype)} Specifies the variance estimation method:\n{p_margin}\n{opt vce(bootstrap)} Uses bootstrap standard errors{p_end}\n\n{phang}\n{opt rob:ust} Uses robust standard errors.\n\n{phang}\n{opt clus:ter(varname)} Clusters standard errors by the specified variable.\n\n{phang}\n{opt reps(#)} Number of bootstrap replications (default is 50). Only used with {opt vce(bootstrap)}.\n\n{title:Returned Results}\n\n{pstd}\n{cmd:rifqreg} returns the following in {cmd:e()}:\n\n{synoptset 20 tabbed}{...}\n{synopt:{cmd:e(cmd)}}command name, {cmd:rifqreg}{p_end}\n{synopt:{cmd:e(title)}}Title of command{p_end}\n{synopt:{cmd:e(q_tau)}}Sample quantile value{p_end}\n{synopt:{cmd:e(f_tau)}}Density estimate at the quantile{p_end}\n{synopt:{cmd:e(tau)}}Quantile requested{p_end}\n\n{title:Examples}\n\n{phang}Using the auto dataset:{p_end}\n\n{phang2}{cmd:. sysuse auto, clear}{p_end}\n{phang2}{cmd:. rifqreg price weight length foreign, q(0.5) robust}{p_end}\n{phang2}{cmd:. rifqreg price weight length foreign, q(0.75) vce(bootstrap) reps(100)}{p_end}\n{phang2}{cmd:. gen_rif price, q(0.5) gen(rif_price50)}{p_end}\n\n{title:Author}\n\n{pstd}\n[Your Name or Organization]{p_end}\n\n{title:References}\n\n{pstd}\nFirpo, S., Fortin, N., and Lemieux, T. (2009). Unconditional Quantile Regressions. \nEconometrica, 77(3), 953-973.\n\n{title:See Also}\n\n{pstd}\n{help qreg}, {help regress}\n*/\n```\n:::\n\n\n## Conclusion\n\nThe results were quite impresive, and are getting better. In Software like Python, Claude can produce highly complex programs that are almost ready to use. In Stata, it did a good job with minor bugs that I could easily fix. \n\nHowever, I still think I have my job secured. I can easily check and debug the code, or write a better version myself. However, for a quick and dirty solution, it is quite good. And for documentation, it is a life saver.\n\nI have started using this for other cases as well. Write programs for data cleaning, data wrangling, and transformations. It is quite good. I may try to add some of that in this blog in the future.\n\n",
    "supporting": [
      "prog-with-ai_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}